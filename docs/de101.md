# SPARQL Tutorial
Written by: Bharath Selvaraj (bharath.selvaraj@decisym.ai)
Written on: 5/7/25
The goal of this tutorial is to give you the 101 crash course on SPARQL to begin writing queries against DeciSym Data Packages. The goal of this tutorial is for you to understand the basics of the way that graphs are build and how to query the nodes found in those graphs.
SPARQL is a query language and a protocol for searching through Resource Description Framework (RDF). This is the univeral standard query language when it comes to querying RDF files. If you would like more information please refer to this page: https://www.w3.org/TR/2013/REC-sparql11-query-20130321/
## Sections
1. Data
2. Creating a DeciSym Data Package
3. Designing a SPARQL Query
4. Excuting a SPARQL Query
After going through these section a user will be have a basic sense of how SPARQL queries are written and will hopefully begin to write SPARQL queries against their own datasets
### Data
Before diving into SPARQL, it’s important to understand what you're querying—an RDF graph.

What is an RDF Graph?

An RDF (Resource Description Framework) graph is a way to represent information as a collection of simple facts, called triples. Each triple has three parts:

    Subject – the thing you're describing

    Predicate – the property or relationship

    Object – the value or related thing

You can think of an RDF graph like a whiteboard filled with dots and arrows:

    Each dot represents a thing—like a fruit, a city, or a person.

    Each arrow represents a relationship or property—like “has color” or “lives in”.

    A triple is simply a connection:
    Apple → hasColor → Red

When you combine many of these triples, you form a graph—a web of interconnected information that machines can understand and query.
INSERT:PICTURE OF GRAPH

ex: apple.ttl
```r
@prefix ex: <http://example.org/>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.

ex:Apple rdf:type ex:Fruit;
  rdfs:label "Apple";
  ex:variety "Red Delicious";
  ex:hasColor "Red";
  ex:weight "150 grams";
  ex:origin "United States";
  ex:isOrganic true.

ex:Fruit rdf:type rdfs:Class;
  rdfs:label "Fruit".
```

Based on the inforamtion provided we can extract the triple information into english:

```s
Apple
- **Type:** Fruit
- **Label:** Apple
- **Variety:** Red Delicious
- **Color:** Red
- **Weight:** 150 grams
- **Origin:** United States
- **Is Organic:** true

---

Fruit
- **Type:** Class
- **Label:** Fruit
```

### Designing a SPARQL Query
In this section of the tutorial we take a look at writing a simple Turtle (.ttl) file and write a SPARQL query against it. Think of this as the "hello world" of SPARQL

So based on the information provided in the "Data" section of the guide for an apple, know we know the following:

Apple is a type of fruit. It is labeled "Apple" and belongs to the variety "Red Delicious".  
It has a red color and weighs 150 grams. The apple originates from the United States and is organic.

"Fruit" is defined as a class and is labeled "Fruit".

Take for example we wanted to know the color of the apple. We know the following information as "The apple has the color red". We would look at the patterns of the triples and we would be able to conclude the following:

ex: find_fruit_color.rq
```
SELECT ?fruit ?color
WHERE {
  ?fruit <http://example.org/hasColor> ?color
}
```

Let’s break down what’s happening in this query: SELECT ?fruit ?color: We want to retrieve two pieces of information — the subject (?fruit) and its color (?color). WHERE { ... }: This block defines the pattern we're searching for in the RDF data. ?fruit <http://example.org/hasColor> ?color: This means we’re looking for any entity (?fruit) that has a hasColor relationship with some value (?color).

In simpler terms: "Find any fruit that has a color, and return both the fruit and the color."

This is the basic building block of querying RDF data with SPARQL — identifying patterns in the data and expressing them with variables and IRIs.

So the SELECT statement that we wrote is looking for that specific iri.

### Running a SPARQL Query

Now to test the SPARQL query and ensure it executes properly we would need to execute the following:

```
user@skynet: de query --data banana.nt --sparql query-fruit-color.rq 
fruit,color
http://example.org/Banana,yellow
```

Now, the results displayed match the hypothesis we concluded previously 

### Joining Data Sets
You're probably thinking of the so what? or who cares? What makes triples stores so special that a SQL or property graph couldnt just solve on its own? The power of triple stores comes when you can start traversing multiple graphs

